# angularjs-play

## Introduction
Demo project using AngularJS, RequireJS and the PlayFramework. Uses/solves the following:

* Dependency injection (using Guice)
* Unit testing of AngularJS controllers/services/directives
* Unit testing of Play controllers using Scalatest/Mockito
* End to end testing using Scalatest/Scalatest Plus/Selenium
* Use Slick
* Write integration tests for Slick using DbUnit
* Implement authentication and authorization for Play
* Basic user/role management screens
* AngularJS form validation
* Localization
* Demonstration of common ui components such as dialogs, table paging, filtering, etc

## Installation and Setup

### Installation
1. Install Play:  https://www.playframework.com/download
2. Install NodeJS: https://nodejs.org/
3. Install ScalaIDE 4.X: http://scala-ide.org/
4. Install PostgreSQL (http://www.postgresql.org/) or have access to 9.X database
     
### Setup
#### Database
Need to create 2 databases - one for the application and another for integration tests. Typically, you would run the following:

```
create user myapp with password 'myapp';
create tablespace myapptb owner myapp location '/<some path>/postgres/myapp';
create database myapp owner=myapp tablespace=myapptb;
create database myapp_test owner=myapp tablespace=myapptb;
```

Or use pgAdmin to create user and databases.

1. Run the scripts database/schema.sql on both the myapp and myapp_test databases
2. On myapp database, run database/sample_data.sql

Note these need to be run as myapp user.

#### Play
Edit the activator start script and include

```
set SBT_OPTS="-Dsbt.jse.engineType=Node" (Windows)
SBT_OPTS="-Dsbt.jse.engineType=Node" (Linux/Mac)  
```

At the play prompt, type:

eclipse

Then import the project into ScalaIDE.

Run the application with command 'run' and open browser to http://localhost:9000. Login with: 

```
simon@email.com
password
```

## Testing
### Karma/Jasmine testing
These are located under test/unit. Assuming you have got NodeJS installed, run with:

```
npm install -g grunt-cli
npm install
grunt karma:dist
```

### Play Controller Testing
These are located under test/controllers

UsersTest is probably the most complete. Use Mockito to mock out the injected interfaces and avoid having to access the db.

These tests are written with specs2 (https://www.playframework.com/documentation/2.3.x/ScalaTestingWithSpecs2)

### Integration Testing
For many Java projects I have worked on, I have used DbUnit to test any SQL/DAO code. I think it's important because it's 
easy for someone to change a query and not realise that it has broken some other code. Or if there is a schema change and the SQL
hasn't been updated to reflect the change. There is a need to at least run the SQL code.

But I have found that the data set formats provided by DbUnit are not to my liking. Excel spreadsheet datasets are unwieldy and
suck when it comes to storing date-time values. The XML format is a bit verbose. So my choice of dataset format has been
JSON and I have based implementation on [3].

One downside of DbUnit tests is that they are incredibly slow. The reason for the slowness is because it needs to figure out the
truncate and insert order. The solution has been to include the insert order with the dataset and avoid this lengthly operation.

So starting with [3] and converting it to Scala (using Play JSON API), I wrote integration.dbunit.JSONDataSet.scala. The insert/truncate
order is stored in the file test/integration/insertSequence.json. This is generated by running integration.dbunit.GenerateDatabaseInsertOrder.scala.
 
All integration tests use the trait integration.dbunit.AbstractIntegrationTest.scala and setup the database before running the test e.g.

```
  var hasInitialisedDatabase = false
   
  before {
     if (!hasInitialisedDatabase) {
       setUpBeforeClass("test/integration/usersDataset.json")
       hasInitialisedDatabase = true
     }
  }
```       

### End to end Testing
These are located under test/e2e. 

End to end testing is the final piece of the unit testing puzzle which I needed to solve. AngularJS e2e testing is typically done using Protractor, 
which I could still have used. However, I wanted an e2e test with the Play application. Scalatest/Scalatest Plus provide a DSL which does this and it
is the same as Protractor. The tricky part is that you need to control the server side reponses so that you can test different cases. This is where
using Guice comes in handy. Service traits can be mocked and injected into the controllers. e2e testing also gives the controller methods an 
additional test coverage. 

Need to install Chrome driver: https://code.google.com/p/selenium/wiki/ChromeDriver

From the play prompt, compile using test:compile and run with test.

When running tests from ScalaIDE, found that I need to compile from the play command line.

## Authorization
I initially looked at Deadbolt and started using it. In the end I rolled my own solution (based on Deadbolt). See controllers/Security.scala
for details and security package.

## Form Validation
There have been a few form validation modules written (just search http://ngmodules.org/) which I could have used. I wrote my own solution
to suit my own requirement - to display a popover whenever there is an invalid field. I have combined several directives I found with my own.
See app/assets/javascripts/common/directives/validate.js for details and acknowledgments. The unit test UiValidateDirectiveSpec.js illustrates
how to use the directive(s).  

## TODO
* Run karma tests as part of the build
* Code coverage reports
* Use LESS 

## References
[1] http://typesafe.com/activator/template/play-angular-require-seed

[2] https://github.com/juanignaciosl/wedding-tables-planner-web

[3] http://danhaywood.com/2011/12/20/db-unit-testing-with-dbunit-json-hsqldb-and-junit-rules/
